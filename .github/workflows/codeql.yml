name: CodeQL Auto-Fix with Devin

on:
  pull_request:
    branches: ["main", "master", "develop"]
    types: [opened, synchronize, reopened]
  push:
    branches: ["main", "master", "develop"]
  schedule:
    - cron: '0 0 * * *'
  workflow_dispatch:
    inputs:
      max_issues:
        description: 'Maximum number of CodeQL issues to fix in this session'
        required: false
        default: '30'

permissions:
  contents: read
  pull-requests: write
  security-events: read
  actions: read

jobs:
  codeql-scan:
    name: CodeQL Scan
    runs-on: ubuntu-latest
    permissions:
      security-events: write
      actions: read
      contents: read
    strategy:
      fail-fast: false
      matrix:
        language: ["python"]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Initialize CodeQL
        uses: github/codeql-action/init@v3
        with:
          languages: ${{ matrix.language }}
          queries: security-and-quality

      - name: Autobuild
        uses: github/codeql-action/autobuild@v3

      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v3
        with:
          category: "/language:${{ matrix.language }}"
          output: codeql-results
          upload: always

      - name: Upload SARIF results as artifact
        uses: actions/upload-artifact@v4
        with:
          name: codeql-sarif-${{ matrix.language }}
          path: codeql-results/*.sarif
          retention-days: 7

  group-alerts:
    name: Group Alerts by Vulnerability Type
    runs-on: ubuntu-latest
    needs: codeql-scan
    outputs:
      batches: ${{ steps.group.outputs.batches }}
      has_issues: ${{ steps.group.outputs.has_issues }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download all SARIF artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: codeql-sarif-*
          merge-multiple: true
          path: sarif-results/

      - name: Group alerts by vulnerability type
        id: group
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            const sarifDir = 'sarif-results';
            const files = fs.readdirSync(sarifDir).filter(f => f.endsWith('.sarif'));

            // Map of vulnerability type -> list of findings
            const groupedAlerts = {};

            for (const file of files) {
              const sarif = JSON.parse(fs.readFileSync(path.join(sarifDir, file), 'utf8'));

              for (const run of sarif.runs || []) {
                const rules = {};
                for (const rule of run.tool?.driver?.rules || []) {
                  rules[rule.id] = {
                    name: rule.name,
                    description: rule.shortDescription?.text || rule.id,
                    tags: rule.properties?.tags || [],
                    severity: rule.properties?.['problem.severity'] || 'warning'
                  };
                }

                for (const result of run.results || []) {
                  const ruleId = result.ruleId;
                  const ruleInfo = rules[ruleId] || { name: ruleId, tags: [], severity: 'warning' };

                  // Determine vulnerability category from CWE tags or rule name
                  let vulnType = classifyVulnerability(ruleId, ruleInfo.tags, ruleInfo.name);

                  if (!groupedAlerts[vulnType]) {
                    groupedAlerts[vulnType] = [];
                  }

                  for (const loc of result.locations || []) {
                    const filePath = loc.physicalLocation?.artifactLocation?.uri;
                    const startLine = loc.physicalLocation?.region?.startLine;
                    groupedAlerts[vulnType].push({
                      ruleId,
                      ruleName: ruleInfo.name,
                      description: ruleInfo.description,
                      severity: ruleInfo.severity,
                      file: filePath,
                      line: startLine,
                      message: result.message?.text || ''
                    });
                  }
                }
              }
            }

            function classifyVulnerability(ruleId, tags, ruleName) {
              const id = (ruleId + ruleName).toLowerCase();
              const tagStr = tags.join(' ').toLowerCase();

              if (id.includes('sql') || tagStr.includes('cwe-89'))   return 'sql-injection';
              if (id.includes('xss') || id.includes('cross-site') || tagStr.includes('cwe-79')) return 'xss';
              if (id.includes('path') || id.includes('traversal') || tagStr.includes('cwe-22')) return 'path-traversal';
              if (id.includes('command') || id.includes('injection') || tagStr.includes('cwe-78')) return 'command-injection';
              if (id.includes('deserializ') || tagStr.includes('cwe-502')) return 'insecure-deserialization';
              if (id.includes('credential') || id.includes('hardcod') || tagStr.includes('cwe-798')) return 'hardcoded-credentials';
              if (id.includes('xxe') || tagStr.includes('cwe-611')) return 'xxe';
              if (id.includes('ssrf') || tagStr.includes('cwe-918')) return 'ssrf';
              if (id.includes('redirect') || tagStr.includes('cwe-601')) return 'open-redirect';
              if (id.includes('csrf') || tagStr.includes('cwe-352')) return 'csrf';
              if (id.includes('crypto') || id.includes('cipher') || tagStr.includes('cwe-327')) return 'weak-cryptography';
              if (id.includes('null') || id.includes('dereference')) return 'null-dereference';
              return 'other-security';
            }

            const batches = Object.entries(groupedAlerts)
              .filter(([, issues]) => issues.length > 0)
              .map(([type, issues]) => ({ type, issues, count: issues.length }));

            const hasIssues = batches.length > 0;
            console.log(`Found ${batches.length} vulnerability type(s) with issues`);
            batches.forEach(b => console.log(`  - ${b.type}: ${b.count} issue(s)`));

            core.setOutput('batches', JSON.stringify(batches));
            core.setOutput('has_issues', hasIssues.toString());

  fetch-live-alerts:
    name: Fetch Live CodeQL Alerts
    runs-on: ubuntu-latest
    needs: codeql-scan
    outputs:
      alert_map: ${{ steps.fetch.outputs.alert_map }}
    steps:
      - name: Fetch open CodeQL alerts via API
        id: fetch
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const alerts = await github.paginate(
              github.rest.codeScanning.listAlertsForRepo,
              {
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                tool_name: 'CodeQL',
                per_page: 100
              }
            );

            // Map alert numbers by rule ID for cross-reference
            const alertMap = {};
            for (const alert of alerts) {
              const rule = alert.rule?.id;
              if (!alertMap[rule]) alertMap[rule] = [];
              alertMap[rule].push({
                number: alert.number,
                url: alert.html_url,
                severity: alert.rule?.severity,
                file: alert.most_recent_instance?.location?.path,
                line: alert.most_recent_instance?.location?.start_line
              });
            }

            core.setOutput('alert_map', JSON.stringify(alertMap));
            console.log(`Fetched ${alerts.length} open CodeQL alert(s)`);


  trigger-devin-fixes:
    name: Trigger Devin Fixes
    runs-on: ubuntu-latest
    needs: [group-alerts, fetch-live-alerts]
    if: needs.group-alerts.outputs.has_issues == 'true'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Build Devin prompt for all issues
        id: build-prompt
        uses: actions/github-script@v7
        env:
          BATCHES_JSON: ${{ needs.group-alerts.outputs.batches }}
          ALERT_MAP_JSON: ${{ needs.fetch-live-alerts.outputs.alert_map }}
          MAX_ISSUES: ${{ github.event.inputs.max_issues || '30' }}
        with:
          script: |
            const batches = JSON.parse(process.env.BATCHES_JSON || '[]');
            const alertMap = JSON.parse(process.env.ALERT_MAP_JSON || '{}');
            const maxIssues = parseInt(process.env.MAX_ISSUES, 10) || 30;
            const prNumber = context.payload.pull_request?.number;
            const repoUrl = `https://github.com/${context.repo.owner}/${context.repo.repo}`;
            const targetBranch = context.payload.pull_request?.head?.ref || context.ref.replace('refs/heads/', '');
            const branchNameSuffix = prNumber ? `pr${prNumber}` : `${targetBranch}`;
            const linkText = prNumber ? `and a link back to PR #${prNumber}` : `and mention that this fixes automated CodeQL findings on branch ${targetBranch}`;

            let totalIssues = 0;
            let batchList = "";

            for (const batch of batches) {
              if (totalIssues >= maxIssues) break;
              
              const remainingQuota = maxIssues - totalIssues;
              const issuesToProcess = batch.issues.slice(0, remainingQuota);
              
              batchList += `\n### Batch: ${batch.type.toUpperCase().replace(/-/g, ' ')} (${issuesToProcess.length} issues)\n`;
              let issueIndex = 1;
              for (const issue of issuesToProcess) {
                totalIssues++;
                const liveAlerts = alertMap[issue.ruleId] || [];
                const alertUrls = liveAlerts.map(a => a.url).join(', ');
                batchList += `${issueIndex++}. **${issue.ruleName}** in \`${issue.file}:${issue.line}\`\n`;
                batchList += `  - Message: ${issue.message}\n`;
                batchList += `  - Severity: ${issue.severity}\n`;
                batchList += `  - GitHub Alert(s): ${alertUrls || 'see SARIF results'}\n`;
              }
            }

            const prompt = `You are a security engineer. Fix the vulnerabilities found by CodeQL in this repository.

            ## Repository
            ${repoUrl}
            Branch to fix: \`${targetBranch}\`

            ## Vulnerabilities to Fix (${totalIssues} issue(s) total)
            ${batchList}

            ## Instructions
            You must resolve the vulnerabilities in batches. Create a separate PR for each batch.
            To prevent merge conflicts, you must run these sequentially and "stack" your branches:

            1. Clone the repository and checkout the branch to fix: \`${targetBranch}\`.
            2. For each batch (in the order listed above):
               a. Create a new branch based on your CURRENT state (so it includes fixes from previous batches). Name it \`fix/codeql-<batch-type>-${branchNameSuffix}-<timestamp>\`.
               b. Fix ALL issues in that specific batch.
               c. Follow secure coding best practices ‚Äî do NOT just suppress warnings.
               d. Ensure existing tests still pass; add new tests if appropriate.
               e. Commit with message: \`fix(security): resolve <batch-type> CodeQL findings\`
               f. Push the branch and open a **DRAFT** pull request targeting \`${targetBranch}\`.
               g. PR title: \`[Security] Fix <batch-type> CodeQL finding(s)\`.
               h. PR description must include: list of fixed files, brief explanation of each fix, ${linkText}.

            By basing each new branch on the previous one, you ensure that all PRs can be merged without conflicts.

            ## Do NOT
            - Merge without human review
            - Suppress/ignore alerts with comments
            - Change unrelated code
            - Break existing functionality`;

            core.setOutput('prompt', prompt);
            core.setOutput('total_issues', totalIssues);
            console.log(`Built prompt for ${totalIssues} issues`);

      - name: Trigger Devin API session
        id: devin
        env:
          DEVIN_API_KEY: ${{ secrets.DEVIN_SERVICE_USER_TOKEN }}
          DEVIN_ORG_ID: ${{ secrets.DEVIN_ORG_ID }}
        run: |
          PROMPT=$(cat << 'PROMPT_EOF'
          ${{ steps.build-prompt.outputs.prompt }}
          PROMPT_EOF
          )

          RESPONSE=$(curl -s -X POST "https://api.devin.ai/v3beta1/organizations/${DEVIN_ORG_ID}/sessions" \
            -H "Authorization: Bearer ${DEVIN_API_KEY}" \
            -H "Content-Type: application/json" \
            -d "{
              \"prompt\": $(echo "$PROMPT" | jq -Rs .),
              \"max_acu_limit\": 50
            }")

          echo "Devin API Response: $RESPONSE"

          SESSION_ID=$(echo "$RESPONSE" | jq -r '.session_id // empty')
          SESSION_URL=$(echo "$RESPONSE" | jq -r '.url // empty')

          if [ -z "$SESSION_ID" ] || [ "$SESSION_ID" = "null" ]; then
            echo "::error::Devin session creation failed. Cannot proceed."
            exit 1
          else
            echo "session_id=$SESSION_ID" >> $GITHUB_OUTPUT
            echo "session_url=$SESSION_URL" >> $GITHUB_OUTPUT
            echo "::notice::Devin session started: $SESSION_URL"
          fi

      - name: Comment on PR with Devin session details
        if: ${{ always() && github.event_name == 'pull_request' }}
        uses: actions/github-script@v7
        env:
          BATCHES_JSON: ${{ needs.group-alerts.outputs.batches }}
          TOTAL_ISSUES: ${{ steps.build-prompt.outputs.total_issues }}
          SESSION_ID: ${{ steps.devin.outputs.session_id }}
          SESSION_URL: ${{ steps.devin.outputs.session_url }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const batches = JSON.parse(process.env.BATCHES_JSON || '[]');
            const totalIssues = process.env.TOTAL_ISSUES || '0';
            const batchesCount = batches.length;
            const sessionId = process.env.SESSION_ID || '';
            const sessionUrl = process.env.SESSION_URL || '';
            const prNumber = context.payload.pull_request?.number;

            const icon = sessionId ? 'ü§ñ' : '‚ö†Ô∏è';
            const status = sessionId
              ? `Started ‚Äî [View Session](${sessionUrl})`
              : 'Failed to start ‚Äî check GitHub Actions logs';

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: `${icon} **CodeQL Auto-Fix** üõ°Ô∏è

            | Field | Value |
            |-------|-------|
            | Total Issues Found | ${totalIssues} |
            | Vulnerability Batches | ${batchesCount} |
            | Devin Session | ${status} |                 

            Devin will resolve the issues sequentially in batches. A separate **draft PR** will be opened for each batch to prevent merge conflicts.`
            });

  no-issues-comment:
    name: Comment ‚Äî No Issues Found
    runs-on: ubuntu-latest
    needs: group-alerts
    if: needs.group-alerts.outputs.has_issues == 'false' && github.event_name == 'pull_request'
    steps:
      - name: Post clean bill of health
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              body: `‚úÖ **CodeQL Scan Complete** ‚Äî No security issues found! This PR is clear of all CodeQL vulnerability checks.`
            });